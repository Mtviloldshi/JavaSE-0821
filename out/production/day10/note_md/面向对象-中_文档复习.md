## 面向对象基础--中
* 面向对象三大特征：封装、继承、多态

#### 封装

* 封装可以被认为是一个保护屏障，防止
  该类的代码和数据被其他类随意访问。适当的封装可以让代码更容易理解与维护，也加强了代码的安全
  性。
  
*  高内聚：类的内部数据操作细节自己完成，不允许外部干涉；
*  低耦合：仅对外暴露少量的方法用于使用
*  隐藏对象内部的复杂性，只对外公开简单的接口。便于外界调用，从而提高系统的可扩展性、可维护
*  性。通俗的讲，把该隐藏的隐藏起来，该暴露的暴露出来。这就是封装性的设计思想。 

* 权限修饰符对于封装的重要性  
    * 便于使用者正确使用系统，防止错误修改属性
    * 有助于系统之间的松耦合，提高系统独立性
    * 提高软件的可重用性
    * 降低了构建大型系统的风险
    
* protected修饰非静态成员，跨包时，只能在子类的非静态成员中访问，在静态成员中无论是否
  创建对象都不能访问。
  
##### 封装的实现    

* 成员变量（field）私有化之后，提供标准的get/set方法，我们把这种成员变量也称为属性
  （property）。或者可以说只要能通过get/set操作的就是事物的属性，哪怕它没有对应的成员变量。
  
* 成员变量封装的目的
    * 隐藏类的实现细节
      让使用者只能通过事先预定的方法来访问数据，从而可以在该方法里面加入控制逻辑，限制
      对成员变量的不合理访问。还可以进行数据检查，从而有利于保证对象信息的完整性。
    * 便于修改，提高代码的可维护性。主要说的是隐藏的部分，在内部修改了，如果其对外可以
      的访问方式不变的话，外部根本感觉不到它的修改。
      >例如：Java8->Java9，String从char[]转
      为byte[]内部实现，而对外的方法不变，我们使用者根本感觉不到它内部的修改。   
* 如何解决局部变量与成员变量同名问题？
   * 当局部变量与类变量（静态成员变量）同名时，在类变量前面加“类名."；
   * 当局部变量与实例变量（非静态成员变量）同名时，在实例变量前面加“this.”  

* this代表当前对象的引用，即当前被创建的对象              

#### 构造器

* 作用：用于创建并初始化对象    

* 注意事项：
  1. 构造器名必须与它所在的类名必须相同。
  2. 它没有返回值，所以不需要返回值类型，甚至不需要void
  3. 如果你不提供构造器，系统会给出默认无参数构造器，并且该构造器的修饰符默认与类的修饰符相同
  4. 如果你提供了构造器，系统将不再提供无参数构造器，除非你自己定义。
  5. 构造器是可以重载的，既可以定义参数，也可以不定义参数。
  6. 构造器的修饰符只能是权限修饰符，不能被其他任何修饰     
  
### 属性赋值

* 赋值的位置及先后顺序：
    * ① 默认初始化 ② 显式初始化 ③ 构造器中初始化 ④ 通过“对象 .属性“或对象 .方法”的式赋值   
    
#### 标准JavaBean  

*  （1）类必须是具体的和公共的，
*  （2）并且具有无参数的构造方法，
*  （3）成员变量私有化，并提供用来操作成员变量的set 和get 方法。
    * （比较理解POJO : Plain Ordinary Java Object，主要承载数据，不涉及业务逻辑） 
    
### 继承 

* 继承的使用：
    * 多个类中存在相同属性和行为时，将这些内容抽取到单独一个类中，那么多个类中无需再定义这些
    属性和行为，只需要和抽取出来的类构成某种关系 
    * 其中，多个类可以称为子类，也叫派生类；多个类抽取出来的这个类称为父类、超类
      （superclass）或者基类。                                                            

* 继承的好处
    *  提高代码的复用性。
    *  提高代码的扩展性。
    *  类与类之间产生了关系，是学习多态的前提。    
    
* 继承中成员变量的特点
    * 子类可以继承父类的所有属性和方法，并直接使用（私有的例外）
    
    * 父类的私有属性（private）
        * 子类继承父类的所有的属性，但是私有的属性不能直接访问（也可以理解为私有的属性不能
          被继承，官方文档中的说法）
        * 子类不能直接进行访问父类的私有属性，但可以通过继承的getter/setter方法进行访问 
        
    * 父子类成员变量重名（初始super关键字）
        * 父类的成员变量会被子类继承，并可以直接使用，也可以在子类中定义同名的成员变量，这样会隐
          藏掉父类的成员变量（不建议）。
        * (也可以理解为就近访问-就近原则）。如果还想在子类中访问父类的成员变量，可以使用关键字
          super。   
          
* 方法重写（Override）

    * 使用场景：子类中定义与父类中相同的方法，一般方法体不同，用于改造并覆盖父类的方法。
    
    * 具体要求：
        *  1.必须保证父子类之间方法的名称相同，参数列表也相同。
        *  2.子类方法的返回值类型必须与父类方法的返回值类型相同或者为父类方法返回值类型的子类类型。
        *  3.子类方法的访问权限必须不能小于父类方法的访问权限。（public > protected > 缺省 > private）
        *  4.子类方法 抛出的异常不能大于父被重写的异常（异常后面再讲  
        
    * 注意事项：
        * 静态方法不能被重写，方法重写指的是实例方法重写，静态方法属于类的方法不能被重写，而是隐
        藏。
        * 私有等在子类中不可见的方法不能被重写
        * final方法不能被重写
        
* 继承中的构造方法   

    * 子类对象实例化过程中必须先完成从父类继承的成员变量的实例初始化，这个过程是通过调用父类的构
      造方法来完成的。
    * 也就是说子类的构造方法中至少有一个构造方法显示或隐式的通过super关键字调用了父类的某一个构
      造方法，否则编译失败
         *  super()：表示调用父类的无参实例初始化方法，要求父类必须有无参构造，而且可以省略不写；
         *  super(实参列表)：表示调用父类的有参实例初始化方法，当父类没有无参构造时，子类的构造器
         *  首行必须写super(实参列表)来明确调用父类的哪个有参构造（其实是调用该构造器对应的实例初始方法）
         *  super()和super(实参列表)都只能出现在子类构造器的首行   
       
#### this和super关键字  

* this使用位置：
    * this在实例初始化相关的代码块和构造器中：表示正在创建的那个实例对象，即正在new谁，this就代表谁
    * this在非静态实例方法中：表示调用该方法的对象，即谁在调用，this就代表谁。
    * this不能出现在静态代码块和静态方法中   

* this的特点
    * 当方法的局部变量与当前对象的成员变量重名时，就可以在成员变量前面加this.，如果
      没有重名问题，就可以省略this.
    * this.成员变量会先从本类声明的成员变量列表中查找，如果未找到，会去从父类继承的
      在子类中仍然可见的成员变量列表中查找
    * this()或this(实参列表)
        * 只能调用本类的其他构造器，必须在构造器的首行，如果一个类中声明了n个构造器，
        * 则最多有 n - 1个构造器中使用了"this(【实参列表】)"，否则会发生递归调用死循环  
        
* super使用的前提
    *  通过super引用父类的xx，都是在子类中仍然可见的
    *  不能在静态代码块和静态方法中使用super 

* super的使用：
    * super.成员变量：
      在子类中访问父类的成员变量，特别是当子类的成员变量与父类的成员变量重名时。
    * super.成员方法：
      在子类中调用父类的成员方法，特别是当子类重写了父类的成员方法时  
    * super()或super(实参列表)：
      在子类的构造器首行，用于表示调用父类的哪个实例初始化方法   

> super() 和 this() 都必须是在构造方法的第一行，所以不能同时出现。 

* 就近原则和追根溯源原则 
    * 在继承关系中，如果要访问变量或方法，通常遵循就近原则和追根溯源原则，即先在调用位置最近的位
      置查找变量或方法，如果没有则去父类找查找，找不到则报错  

* 1、找变量
>  没有super和this  
         >  在构造器、代码块、方法中如果出现使用某个变量，先查看是否是当前块声明的局部变量，  
         > 如果不是局部变量，先从当前执行代码的本类去找成员变量  
         > 如果从当前执行代码的本类中没有找到，会往上找父类的（非private，跨包还不能是缺省的）  
  this ：代表当前对象  
        > 通过this找成员变量时，先从当前执行代码的本类中找，没有的会往上找父类的（非private，跨包还不能是缺省的）。  
  super ：代表父类的  
        > 通过super找成员变量，直接从当前执行代码所在类的父类找  
  super()或super(实参列表)只能从直接父类找  
        > 通过super只能访问父类在子类中可见的（非private，跨包还不能是缺省的）

* 注意：super和this都不能出现在静态方法和静态代码块中，因为super和this都是存在与对象中的    

#### 成员变量初始化

* 代码块
    * 静态初始化块：在类初始化时由类加载器调用执行，每一个类的静态初始化只会执行一次，早于实例对
      象的创建。
    * 实例初始化块：每次new实例对象时自动执行，每new一个对象，执行一次。  
    
* 构造器
    * 构造器只为实例变量初始化，不为静态类变量初始化
    * 为实例变量初始化，再new对象时由对象的创建者决定为当前对象的实例变量赋什么值。
    
#### 类初始化

* 1.类初始化的目的：为类中的静态变量进行赋值。
* 2.实际上，类初始化的过程时在调用一个()方法，而这个方法是编译器自动生成的。编译器会将如下
  两部分的所有代码，按顺序合并到类初始化()方法体中。
    * （1）静态类成员变量的显式赋值语句
    * （2）静态代码块中的语句
* 3.整个类初始化只会进行一次，如果子类初始化时，发现父类没有初始化，那么会先初始化父类。
    
  ```java
    public class Test{
      public static void main(String[] args){
        Father.test();
        }
    }
    class Father{
      private static int a = getNumber();//这里调用方法为a变量显式赋值的目的是为了看到这个过程
        static{
        System.out.println("Father(1)");
    }
      private static int b = getNumber();
        static{
        System.out.println("Father(2)");
    }
      public static int getNumber(){
        System.out.println("getNumber()");
        return 1;
    }
      public static void test(){
          System.out.println("Father:test()");
    }
  }
  ``` 
* 结论：
  * 每一个类都有一个类初始化方法()方法，然后子类初始化时，如果发现父类加载和没有初始化，会
  先加载和初始化父类，然后再加载和初始化子类。一个类，只会初始化一次。
  
#### 实例初始化

* 1.实例初始化的目的：为类中非静态成员变量赋值 

* 2.实际上我们编写的代码在编译时，会自动处理代码，整理出一个()的类初始化方法，还会整理出一
  个或多个的(...)实例初始化方法。一个类有几个实例初始化方法，由这个类有几个构造器决定。
  实例初始化方法的方法体，由四部分构成 
  * （1）super()或super(实参列表) 这里选择哪个，看原来构造器首行是哪句，没写，默认就是
    super()
  * （2）非静态实例变量的显示赋值语句                                                   
  * （3）非静态代码块
  * （4）对应构造器中的代码
    > 特别说明：其中（2）和（3）是按顺序合并的，（1）一定在最前面（4）一定在最后面
                   
* 3.执行特点：
  * 创建对象时，才会执行
  * 每new一个对象，都会完成该对象的实例初始化
  * 调用哪个构造器，就是执行它对应的实例初始化方法
  * 创建子类对象时，父类对应的实例初始化会被先执行，执行父类哪个实例初始化方法，看用
    super()还是super(实参列表)
  * 4. 示例代码1：单个类
  ```java
    public class Test{
        public static void main(String[] args){
            Father f1 = new Father();
            Father f2 = new Father("atguigu");
          }
        }
        class Father{
            private int a = getNumber();
            private String info;
        {
          System.out.println("Father(1)");
        }
        Father(){
          System.out.println("Father()无参构造");
        }
        Father(String info){
              this.info = info;
              System.out.println("Father(info)有参构造");
        }
          private int b = getNumber();
        {
              System.out.println("Father(2)");
        }
            public int getNumber(){
              System.out.println("Father:getNumber()");
              return 1;
        }
    }
  ``` 
* 子类重写getNumber()方法，那么创建子类的对象，就是调用子类的
  getNumber()方法，因为当前对象this是子类的对象 
  
#### 类初始化与实例初始化比较  

* 类初始化肯定优先于实例初始化。
* 类初始化只做一次。
* 实例初始化是每次创建对象都要进行
    * 示例
    ```java
      public class Test{
          public static void main(String[] args){
              Son s1 = new Son();
              System.out.println("----------------------------");
              Son s2 = new Son();
          }
      }
      class Father{
          static{
              System.out.println("Father:static");
      }
          {
               System.out.println("Father:not_static");
      }
          Father(){
              System.out.println("Father()无参构造");
      }
  }
      class Son extends Father{
          static{
              System.out.println("Son:static");
      }
          {
              System.out.println("Son:not_static");
      }
          Son(){
              System.out.println("Son()无参构造");
      }
  }
    ``` 
  
### 多态  

#### 多态的理解

* 引用类型变量在编译期呈现左边父类的行为特征，运行时呈现右边创建的不同子类对象的行为特征。
  >即：编译看左边，运行看右边。
                                                 
#### 多态的前提 

*  1.有继承关系
*  2.有方法重写 
    * 如果没有方法重写，运行时调用子类的方法，实际还是调用的从父类继承的方法，不具有多态性                                                

#### 多态的好处

* 1.提高程序的扩展性（参考引入案例分析）
* 2.降低类与类直接耦合度（参考引入案例分析） 

#### 多态的应用

* 多态应用在形参实参
    * 父类类型作为方法形式参数，子类对象为实参。
    * 代码如下：    
    ```java
          public class Test01 {
              public static void main(String[] args) {
              showAnimalEat(new Dog()); //形参 Animal a,实参new Dog()
              //实参给形参赋值 Animal a = new Dog() 多态引用
              showAnimalEat(new Cat());//形参 Animal a,实参new Cat()
              //实参给形参赋值 Animal a = new Cat() 多态引用
          }
          /*
          * 设计一个方法，可以查看所有动物的吃的行为
          * 关注的是所有动物的共同特征：eat()
          * 所以形参，设计为父类的类型
          * 此时不关注子类特有的方法
          */
          public static void showAnimalEat (Animal a){
              a.eat();
              // a.catchMouse();//错误，因为a现在编译时类型是Animal，只能看到父类中有的方法
              }
          }
    ```
  
* 多态应用在数组
    * 数组元素类型声明为父类类型，实际存储的是子类对象
    * 代码示例：
    ```java
          public class Test02 {
          public static void main(String[] args) {
                  /*
                  * 声明一个数组，可以装各种动物的对象，看它们吃东西的样子
                  */
                  Animal[] arr = new Animal[2]; //此时不是new Animal的对象，而是newAnimal[]的数组对象
                  //在堆中开辟了长度为5的数组空间，用来装Animal或它子类对象的地址
                  arr[0] = new Cat();//多态引用 左边arr[0] 是Animal类型，右边是new Cat()
                  //把Cat对象，赋值给Animal类型的变量
                  arr[1] = new Dog();
                  for (int i = 0; i < arr.length; i++) {
                      arr[i].eat();
                  // arr[i].catchMouse();错误，因为arr[i]现在编译时类型是Animal，只能看到父类中有的方法
                  }
              }
          }
    ``` 

* 多态应用在返回值
    * 方法的返回值类型声明为父类的类型，实际返回值是子类对象
    * 代码示例
    ```java
          public class Test03 {
              public static void main(String[] args) {
                  Animal c = buy("猫咪");
                  System.out.println(c.getClass());
                  c.eat();
          }
          /*
          * 设计一个方法，可以购买各种动物的对象，此时不确定是那种具体的动物
          *
          * 返回值类型是父类的对象
          *
          * 多态体现在 返回值类型 Animal ，实际返回的对象是子类的new Cat()，或new
          Dog()
          */
          public static Animal buy(String name){
              if("猫咪".equals(name)){
                  return new Cat();
              }else if("小狗".equals(name)){
                  return new Dog();
              }
                  return null;
              }
          }
    ```  
  
#### 向上转型与向下转型

* 首先，一个对象在new的时候创建是哪个类型的对象，它从头至尾都不会变。即这个对象的运行时类
    型，本质的类型用于不会变。这个和基本数据类型的转换是不同的。
* 但是，把这个对象赋值给不同类型的变量时，这些变量的编译时类型却不同。  
 
* 用父类变量接收了子类对象之后，我们就不能调用子类拥有，而父类没有的方法了。这也是多
  态给我们带来的一点"小麻烦"。所以，想要调用子类特有的方法，必须做类型转换。 
    * 向上转型：当左边的变量的类型（父类） > 右边对象/变量的类型（子类），我们就称为向上转型
        此时，编译时按照左边变量的类型处理，就只能调用父类中有的变量和方法，不能调用子类
        特有的变量和方法了但是，运行时，仍然是对象本身的类型此时，一定是安全的，
        而且也是自动完成的
    * 向下转型：当左边的变量的类型（子类）<右边对象/变量的类型（父类），我们就称为向下转型
        此时，编译时按照左边变量的类型处理，就可以调用子类特有的变量和方法了
        但是，运行时，仍然是对象本身的类型
        此时，不一定是安全的，需要使用(类型)进行强制类型转换
        不是所有通过编译的向下转型都是正确的，可能会发生ClassCastException，为了安全，可
        以通过isInstanceof关键字进行判断  
  * 示例代码：   
  ```java
      public class Test {
          public static void main(String[] args) {
          // 向上转型
          Animal a = new Cat();
          a.eat(); // 调用的是 Cat 的 eat
          // 向下转型
          Cat c = (Cat)a;
          c.catchMouse(); // 调用的是 Cat 的 catchMouse
          // 向下转型
          //Dog d = (Dog)a; //这段代码可以通过编译，但是运行时，却报出了ClassCastException
          //这是因为，明明创建了Cat类型对象，运行时，当然不能转换成Dog对象的。这两个类型并没有任何继承关系， //不符合类型转换的定义。
          //d.watchHouse(); // 调用的是 Dog 的 watchHouse
          Animal a2 = new Animal();
          // Dog d2 = (Dog)a2;//这段代码可以通过编译，但是运行时，却报出了ClassCastException
          // d2.watchHouse(); // 调用的是 Dog 的 watchHouse
      }
  }
  ```   
  
* instanceof  
    
    * 为了避免ClassCastException的发生，Java提供了 instanceof 关键字，给引用变量做类型的校验，只
      要用instanceof判断返回true的，那么强转为该类型就一定是安全的，不会报ClassCastException异
      常。
    
    * 对象/变量的编译时类型 与 instanceof后面数据类型是直系亲属关系才可以比较
    * 对象/变量的运行时类型<= instanceof后面数据类型，才为true  
    
#### 多态引用时关于成员变量与成员方法引用的原则

* 1.成员变量：只看编译时类型    
    * 如果直接访问成员变量，那么只看编译时类型
    
* 2.非虚方法：只看编译时类型  
    * 在Java中的非虚方法有三种:
        * （1）由invokestatic指令调用的static方法，这种方法在编译时确定在运行时不会改变。
        * （2）由invokespecial指令调用的方法，这些方法包括私有方法，实例构造方法和父类方法，这些
        方法也是在编译时已经确定，在运行时不会再改变的方法
        *（3）由final关键字修饰的方法。虽然final方法是由invokevirtual指令进行调用的，但是final修饰
        的方法不能够进行在子类中进行覆盖，所有final修饰的方法是不能够在运行期进行动态改变的。
    * 在java语言规范中明确规定final方法就是非虚方法  
    
* 3. 虚方法：静态分派与动态绑定
    > 在Java中虚方法是指在编译阶段和类加载阶段都不能确定方法的调用入口地址，在运行阶段才能确
     定的方法，即可能被重写的方法。  
    * 静态分派：先看这个对象的编译时类型，在这个对象的编译时类型中找到最匹配的方法
        * 最匹配的是指，实参的编译时类型与形参的类型最匹配  
    * 动态绑定：再看这个对象的运行时类型，如果这个对象的运行时类重写了刚刚找到的那个最匹配的
      方法，那么执行重写的，否则仍然执行刚才编译时类型中的那个方法
      
### native关键字
   
   * native：本地的，原生的 
   * 用法：
       * 只能修饰方法
       * 表示这个方法的方法体代码不是用Java语言实现的，而是由C/C++语言编写的。
       * 但是对于Java程序员来说，可以当做Java的方法一样去正常调用它，或者子类重写它。  
       
### final关键字

* final：最终的，不可更改的

* final修饰某个变量（成员变量或局部变量），表示它的值就不能被修改，即常量，常量名建议使
  用大写字母。
  
### Object根父类

* 所有类的父类。每个类都直接或间接继承Object类
    * Object类型的变量与除Object以外的任意引用数据类型的对象都多态引用
    * 所有对象（包括数组）都实现这个类的方法。
    * 如果一个类没有特别指定父类，那么默认则继承自Object类  
    
* 面试题：对finalize()的理解？    
    * 当对象被GC确定为要被回收的垃圾，在回收之前由GC帮你调用这个方法，不是由程序员手动调
        用。
    * 这个方法与C语言的析构函数不同，C语言的析构函数被调用，那么对象一定被销毁，内存被回
        收，而finalize方法的调用不一定会销毁当前对象，因为可能在finalize()中出现了让当前对象“复活”
        的代码
    * 每一个对象的finalize方法只会被调用一次。
    *子类可以选择重写，一般用于彻底释放一些资源对象，而且这些资源对象往往时通过C/C++等代码
        申请的资源内存  

#### Object类下的五个API(方法)

* 1.toString()   : 默认情况下，toString()返回的是“对象的运行时类型 @ 对象的hashCode值的十六进制形式"
* 2.getClass()   : public final Class<?> getClass()：获取对象的运行时类型
* 3.hashcode()   : public int hashCode()：返回每个对象的hash值。         
* 4.equals()     : public boolean equals(Object obj)：用于判断当前对象this与指定对象obj是否“相等”
* 5.finalize()   : protected void finalize()：用于最终清理内存的方法   