### 反射

#### 一.类加载
>类在内存中的生命周期：加载-->使用-->卸载

* 1.类的加载过程
    >当程序主动使用某个类时，如果该类还未被加载到内存中，系统会通过加载、链接、初始化三个步骤来
     对该类进行初始化，如果没有意外，JVM将会连续完成这三个步骤，所以有时也把这三个步骤统称为类
     加载

* 类的加载又分为三个阶段：
    * （1）加载：load
        * 就是指将类型的class字节码数据读入内存
    * （2）连接：link
        * ①验证：校验被加载的class文件的合法性，并且不会危害虚拟机的自身安全（文件格式验证，语
          义分析等）
        * ②准备：为类变量分配内存（在方法区中）并设置初始值（0,null,false），为静态常量赋初始值
          （常量池中）
            * 比如：public static int sector = 3;类变量在此阶段会被设置默认初始值为0，而不是3.
            *  public static final int number = 3;静态常量在此阶段会被设置值为3
        * ③解析：把字节码中的符号引用替换为对应的直接地址引用
          符号引用就是一组符号来描述目标，可以是任何字面量。
          直接引用就是直接指向目标的指针、相对偏移量或一个间接定位到目标的句柄。  
    * （3）初始化：initialize
        * 为类的静态变量赋予正确的初始值，JVM负责对类进行初始化，主要对类变量进行初始化。
          类初始化执行的是()，该方法会执行①类变量的显式赋值代码②静态代码块中的代码，用于给类变
          量初始化值。
          
* 2.类初始化    
    * 哪些操作会导致类的初始化？
        * （1）运行主方法所在的类，要先完成类初始化，再执行main方法
        * （2）第一次使用某个类型就是在new它的对象，此时这个类没有初始化的话，先完成类初始化再做实例初始化
        * （3）调用某个类的静态成员（类变量和类方法），此时这个类没有初始化的话，先完成类初始化
        * （4）子类初始化时，发现它的父类还没有初始化的话，那么先初始化父类
        * （5）通过反射操作某个类时，如果这个类没有初始化，也会导致该类先初始化
        
    * 哪些使用类的操作，但是不会导致类的初始化
        * （1）使用某个类的静态的常量（static final）
        * （2）通过子类调用父类的静态变量，静态方法，只会导致父类初始化，不会导致子类初始化，即只有
        声明静态成员的类才会初始化
        * （3）用某个类型声明数组并创建数组对象时，不会导致这个类初始化    
          
* 3.类加载器
>类的加载通过类加载器完成

* 类加载器分为：
    * （1）引导类加载器（Bootstrap Class Loader）又称为根类加载器  
        * 它负责加载jre/rt.jar核心库
        * 它本身不是Java代码实现的，也不是ClassLoader的子类，获取它的对象时往往返回null        
        
    * （2）扩展类加载器（Extension Class Loader）
        * 它负责加载jre/lib/ext扩展库
        * 它是ClassLoader的子类
        * Java代码编写
        
    * （3）应用程序类加载器（Application Class Loader） 
        * 也称为系统类加载器System Class Loader
        * 它负责加载项目的classpath路径下的类
        * 它是ClassLoader的子类
        * Java代码编写  
        
    * （4）自定义类加载器
        * 当你的程序需要加载“特定”目录下的类，可以自定义类加载器；
        * 当你的程序的字节码文件需要加密时，那么往往会提供一个自定义类加载器对其进行解码
        * tomcat服务器中会应用到
        * Java编写  
        
* Java系统类加载器的双亲委托模式
    >在JVM虚拟机中，如果一个类加载器收到类加载的请求，它首先不会自己去尝试加载这个类，而是把这
     个请求委派给父类加载器完成。每个类加载器都是如此，只有当父加载器在自己的搜索范围内找不到指
     定的类时（即ClassNotFoundException），子加载器才会尝试自己去加载
    * 也就是说，对于每个类加载器，只有父类（依次递归）找不到时，才自己加载 。这就是双亲委派模式           
    
    * 为什么需要双亲委派模型呢？
        * ①这样可以避免重复加载
        * ②考虑到安全因素
        
* 获取类加载器的方式：
    * //获取当前类的加载器
    * ClassLoader classLoader = Demo.class.getClassLoader();
    * //获取当前线程上下文类加载器
    * ClassLoader contextClassLoader = Thread.currentThread().getContextClassLoader();
    * //获取系统类加载器
    * ClassLoader systemClassLoader = ClassLoader.getSystemClassLoader();  
        
#### 二、java.lang.Class类    
* 万物皆对象，每个类编译后生成的字节码文件，即class文件，在类加载后JVM会为每个class文件创建一
  个对象，也就是Class类的一个对象。这个Class对象封装了类在方法区内的数据信息，并且向Java程序
  员提供了访问方法区内的类数据信息的接口
  
>Java反射机制是在运行状态中，对于任意一个类，都能够知道这个类的所有属性和方法；对于任意一个
 对象，都能够调用它的任意一个方法和属性；这种动态获取的信息以及动态调用对象的方法的功能称为
 Java语言的反射机制。

* 要想解剖一个类，必须先要获取到该类的Class对象。所以，Class对象是反射的根源。        

* 获取Class对象的四种方式
    * 1.类名.class;
    * 2.Class.forName(全类名);
    * 3.对象.getClass();
    * 4.ClassLoad.loadClass(全类名);
    
#### 三、反射的应用

* 获取类型的详细信息
    * 1.获取任意引用类型的对象
        * ①.通过字节码对象直接获取,前提是这个类有空参构造器
            * clazz.newInstance();
        * ②.通过字节码对象获取当前类构造器，然后获取该类对象
            * 构造器 cus = clazz.构造器(字节码类型);
            * Object o = cus.newInstance(参数列表)；
            
    * 2.获取属性：
        * ①获取全部公共属性 (public修饰的)
            * clazz.getFields(); 
        * ②获取全部信息(包括私有的)    
            * clazz.getDeclaredFields();
        * ③获取单个公共属性并赋值
            * Field name = clazz.getField(属性名);
            * name.set(对象名,属性值); 
        * ④获取单个非公共属性并赋值
            * Field age = clazz.getDeclaredField(属性名);
            * age.setAccessible(true);//打开访问权限    
            * age.set(对象名，属性值);
            
    * 3.获取方法：
        * ①获取全部公共方法，不包括私有，包括父类的
            * clazz.getMethods();
        * ②获取全部非公共方法，包括私有，不包括父类
            * clazz.getDeclaredMethods();
        * ③获取单个公共有参数，有返回值方法
            * Method pt = clazz.getMethod(String 方法名,参数属性字节类型);
            * Object 返回值 = pt.invoke(对象名,属性值..);            
        * ④获取单个非公共方法，无返回值,有参数
            * Method pit = clazz.getDeclaredMethod(String 方法名,参数属性字节类型);
            * pit.setAccessible(ture);//开启访问权限
            * pit.invoke(对象名,参数值...)   
            
    * 4.获取注解
        * 注解名 注解对象 = clazz.getAnnotation(注解名.class);   
        * 注解对象.value();//获取注解上的值
        
    * 获取泛型 获取内部类 动态创建和操作任意类型的数组。。。    
    