### 面向对象-上

#### 面向对象与面向过程的区别
* 1.面向过程: POP: Process-Oriented Programming

    * 以函数（方法）为最小单位
    * 数据独立于函数之外
    * 面向功能划分软件结构
    * 以过程，步骤为主，考虑怎么做
    * 程序员是具体执行者
    * 制约了软件的可维护性和可扩展性 
    
* 2.面向对象: OOP: Object Oriented Programming   

    * 以类/对象为最小单位，类包括：数据+方法
    * 把软件系统看成各种对象的集合             
    * 以对象（谁）为主，考虑谁来做，谁能做
    * 程序员是指挥者
    * 面向对象仍然包含面向过程，只不过关注点变了，关注谁来做
    * 软件可重用性、可维护性和可扩展性强
 
#### 类与对象的关系

* 类是对一类事物的描述，是抽象的。
* 对象是一类事物的实例，是具体的。
* 类是对象的模板，对象是类的实体。

#### 对象的内存分析    

* 栈
    * 虚拟机栈，用于存储正在执行的每个Java方法的局部变量表等。
    * 局部变量表存放了编译期可知长度的各种基本数据类型、对象引用，方法执行完，自动释放
  
* 堆
    * 存储对象（包括数组对象），new来创建的，都存储在堆内存
    
* 方法区
    * 存储已被虚拟机加载的类信息、常量、静态变量、即时编译器编译后的代码等数据     
    
* 程序计数器
    * 程序计数器是CPU中的寄存器，它包含每一个线程下一条要执行的指令的地址
    
* 本地方法栈    
    * 当程序中调用了native的本地方法时，本地方法执行期间的内存区域
    
#### 包的作用

*  （1）可以避免类重名：有了包之后，类的全名称就变为：包.类名
*  （2）分类组织管理众多的类
*  （3）可以控制某些类型或成员的可见范围

   * 如果某个类型或者成员的权限修饰缺省的话，那么就仅限于本包使用
   
#### 变量的分类

*  局部变量：定义在方法体内或其他局部区域内的变量（之前所使用的都是main方法中定义的变量，为局部变量）。

*  成员变量：定义在类的成员位置，在方法体外，与方法（例如main方法）平行的位置。并且有修饰符修饰。
   根据修饰的不同成员变量又分为：
    * 类变量：或叫静态变量，有static修饰的成员变量。（上例中的country为类变量）
    * 实例变量：没有static修饰的成员变量。
    
#### 成员变量的访问


* 实例变量的访问：
    * 对象名.静态成员变量
    
* 类变量的访问：
   * 类名.静态成员变量
   * 对象名.静态成员变量（不推荐）    
   
####  成员变量的特点     

* 1.成员变量有默认初始值
* 2.类变量的值是所有对象共享的，而实例变量的值是每个对象独立的

#### 方法

*  方法也叫函数，是一个独立功能的定义，是一个类中最基本的功能单元。
*  把一个功能封装为方法的目的是，可以实现代码重用，从而简少代码量。

#### 成员方法的分类

*  实例方法：没有static修饰的方法，必须通过实例对象来调用。
*  静态方法：有static修饰的方法，也叫类方法，主要特点是可以由类名来调用。

#### 3. 形参与实参的概念理解

* 形参：在定义方法时方法名后面括号中声明的变量称为形式参数（简称形参）即形参出现在方法定义时。
     
* 实参：调用方法时方法名后面括号中的使用的值/变量/表达式称为实际参数（简称实参）即实参出现在方法调用时。

#### 方法调用的注意事项

* 调用方法时，实参的个数、类型、顺序必须要与形参列表一一对应
* 调用方法时，如果方法有返回值，可以用与返回值类型相同的变量接受或直接处理返回值结
     果，如果方法的返回值类型是void，不需要也不能接收和处理返回值结果
     
#### 本类内的成员变量和方法访问

* 直接用，不需要加“对象名."和"类名."
* 例外情况：静态方法中不能直接访问本类的非静态的成员变量和成员方法

#### 方法调用内存分析

* 方法不调用不执行，调用一次执行一次，每次调用会在栈中有一个入栈动作，即给当前方法开辟一块独
  立的内存区域，用于存储当前方法的局部变量的值，当方法执行结束后，会释放该内存，称为出栈，如
  果方法有返回值，就会把结果返回调用处，如果没有返回值，就直接结束，回到调用处继续执行下一条
  指令。    
  
#### 方法参数的值传递机制

* 方法的参数传递机制：实参给形参赋值   
    * 方法的形参是基本数据类型时，形参值的改变不会影响实参；
    * 方法的形参是引用数据类型时，形参地址值的改变不会影响实参，但是形参地址值里面的数
      据的改变会影响实参，例如，修改数组元素的值，或修改对象的属性值。
      注意：String、Integer等特殊类型容易错
      
#### 可变参数 

* 在JDK1.5之后，如果我们定义一个方法时，此时某个形参的类型可以确定，但是形参的个数不确定，那
  么我们可以使用可变参数。
  
* （1）一个方法最多只能有一个可变参数
* （2）如果一个方法包含可变参数，那么可变参数必须是形参列表的最后一个  

#### 方法重载     

* 指在同一个类中，允许存在一个以上的同名方法，只要它们的参数列表不同即可，与修饰符
  和返回值类型无关
  
* 参数列表不同：指的是参数个数不同，数据类型不同，数据类型顺序不同  

#### 命令行参数

* 通过命令行给main方法的形参传递的实参称为命令行参数

#### 递归
* 概念：指在当前方法内调用自己的这种现象。

* 递归的分类:
    *  递归分为两种，直接递归和间接递归。
    *  直接递归称为方法自身调用自己。
    *  间接递归可以A方法调用B方法，B方法调用C方法，C方法调用A方法。
    
* 注意事项：
    * 递归一定要有条件限定，保证递归能够停止下来，否则会发生栈内存溢出。
    * 在递归中虽然有限定条件，但是递归次数不能太多。否则也会发生栈内存溢出。  
    
- 示例一：计算1-100之间所有自然数的和  
```java
public class RecursionMethod1{
public static void main(String[] args) {
    int sum = sum(100);
    System.out.println("1-100的和：" + sum);
}
public static int sum(int n){
        if(n == 1){
            return 1;
        }else{
            return n + sum(n-1);
        }
    }
}
```
- 示例二：求n!
```java
public class RecursionMethod2{
public static void main(String[] args) {
    int jieCheng = jieCheng(10);
    System.out.println("10的阶乘是：" + jieCheng);
}
public static int jieCheng(int n){
        if(n <= 1){
        return 1;
        }else{
        return n * jieCheng(n-1);
        }
    }
}
```

#### 对象数组

* 数组是用来存储一组数据的容器，一组基本数据类型的数据可以用数组装，那么一组对象也可以使用数
  组来装
  
* 即数组的元素可以是基本数据类型，也可以是引用数据类型。当元素是引用数据类型时，我们称为对象
  数组。  
  
  * 注意：对象数组，首先要创建数组对象本身，即确定数组的长度，然后再创建每一个元素对象，
    如果不创建，数组的元素的默认值就是null，所以很容易出现空指针异常
    NullPointerException。