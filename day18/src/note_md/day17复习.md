### 集合（完结）

#### Map集合

* 存储一组键值对的一个容器

* 特点：key是唯一的，value是可以重复的，元素无序
* 常用API：
    * put(key,value);//添加元素
    * remove();//删除元素
    * get(key);//根据key获取value
    * size();//集合中元素的个数
    * ketSet();//获取所有的key并封装到一个set集合中
    * values();//获取所有的value并封装到一个Collection集合中
    * entrySet()//获取每一个键值对，把它们看成一个整体，封装刀Set集合

* HashMap实现类
    * 特点：
        * key唯一，无序，key和value都可以为null
        * 底层结构：
            * hash表=数组+链表+红黑树
        * 添加元素的原理：
            * 首次添加元素需要扩容，容量为16
            * 每次添加元素，计算key的hash值，寻找数组中的索引位置，判断此位置是否有元素 
            没有直接插入，如果有则通过比较equals判断是否重复，是则直接覆盖，否则再判断
            是树则进行树操作，如果是链表则遍历链表，判断是否重复的key，重复则覆盖value，
            否则直接尾部插入,插入了新元素判断是否需要转为红黑树或是需要扩容，当链表长度达8，
            并且数组长度大于64时，链表转为红黑树，未达到64则进行扩容操作,扩容两倍。
            > 扩容操作，因要重新计算hash，重新分布元素，所以是很消耗性能的操作  
        
            * 构造：
            * new hashMap()//未初始化容量
            * new hashMap(int initialCapacity)
            
* LinkedHashMap
    * 特点：key唯一，有序的，通过一个双向链表保证了元素的插入顺序。          
    
* TreeMap
    * 特点: key唯一，无序的，实现排序，元素必须可以比较大小,实现（Comparable，Comparator）    
    * 底层结构：红黑树
    
#### Collection工具类

#### 总结    

* 1.什么是集合？
* 2.有数组为什么还要用集合？
* 3.为什么提供这么多集合？
* 4.这些集合都有什么特点？
    * Collection: 存储一组对象，
        * List: 元素有序，可重复
            * ArrayList: 线程不安全的
                * 特点：查询快，增删慢
                * 底层结构：数组
            * LinkedList:线程不安全的
                * 特点: 查询慢、增删快
                * 底层结构：双向链表
            * Vector:
                * 特点：线程安全的，效率低
                * 底层结构：数组
                    * Stack:
        * Set:元素唯一
            * HashSet:无序的，增删、查询都快
                * 特点: 元素唯一
                * 底层结构，哈希表=数组+链表+红黑树
                * LinkedHashSet:
                    * 特点：元素有序
                    * 底层结构：哈希表=数组+链表+红黑树 ，双向链表保证了元素有序
            * TreeSet：
                * 特点：实现排序的，查询效率高于链表，增删效率高于数组
                * 底层结构：红黑树
    * Map: 存储一组映射，键值对 键唯一，值可以重复   
        * HashMap:  
            * 特点： key和value都可以为null，线程不安全的  
            * 底层结构 ： 哈希表 = 数组 + 链表 + 红黑树        
            * LinkedHashMap:
        * TreeMap:
        * HashTable:
            * Properties:
    * Collections: 
    
    > new HashMap()时，数组长度为0，加入第一个元素时，底层数组扩容为16，然后计算当前key的hashCode()，
    进行取模，确定元素在底层数组中的位置，直接添加；
    往后再添加元素时，先计算key的hashCode()值取模确定其在数组上的位置，如果这个位置没有数据直接插入，如果这个位置有数据，
    先与这个位置上的hashCode()值是否相等，如果相等，则比较其equals()是否相等，两个都相等，则这两个对象是相同对象，用新插入对象的value，
    覆盖原对象的value。如果这个两对象不相等，则循环比较这个数组上的链表对象，相等则新value覆盖原value，如果循环完，最后都不相等，
    先判断当前存储方式是链表结构还是，树结构，如果是树结构，按照树结构的插入方式进行插入，如果是链表，则在链表最后插入，
    然后计算先计算哈数组上的链表长度是否等于8，如果小于8，则插入结束，如果等于8，并且数组长度小于64，则把数组进行扩容，重新计算各对象的hash值，
    进行对象分布，如果长度大于64，则转换为树结构。   
* 5.为什么会有这些特特点？
* 6.常用API以及遍历操作