### 多线程

#### 一、相关概念

* 并发与并行（了解）
    * 并行（parallel）：指多个事件任务在同一时刻发生（同时发生）。指在同一时刻，有多条指令在
        多个处理器上同时执行。单核CPU同一时刻只能处理一条指令，所以单核CPU做不到并行处理。
    * 并发（concurrency）：指两个或多个事件在同一个微小的时间段内发生。指在同一个时刻只能有
        一条指令执行，但多个进程的指令被快速轮换执行，使得在宏观上具有多个进程同时执行的效果。
        程序并发执行可以在有限条件下，充分利用CPU资源，这是我们研究的重点。
        >单核CPU：只能并发  
        多核CPU：并行+并发    
                                                                                                                                                           
* 线程与进程
    * 程序：为了完成某个任务和功能，选择一种编程语言编写的一组指令的集合。
    * 软件：1个或多个应用程序+相关的素材和资源文件等构成一个软件系统。
    * 进程：进程是对一个程序运行过程（创建-运行-消亡）的描述，系统会为每个运行的程序建立一个
        进程，并为进程分配独立的系统资源，比如内存空间等资源。
    * 线程：线程是进程中的一个执行单元，负责完成执行当前程序的任务，一个进程中至少有一个线
        程。一个进程中是可以有多个线程的，这个应用程序也可以称之为多线程程序。多线程使得程序可
        以并发执行，充分利用CPU资源。
    面试题：进程是操作系统调度和分配资源的最小单位，线程是CPU调度的最小单位。不同的进程之
    间是不共享内存的。进程之间的数据交换和通信的成本是很高。不同的线程是共享同一个进程的内
    存的。当然不同的线程也有自己独立的内存空间。对于方法区，堆中中的同一个对象的内存，线程
    之间是可以共享的，但是栈的局部变量永远是独立的。
    
* 多线程的优点与应用场景                                                                                                                                                               
    * 主要优点：
        * 充分利用CUP空闲时间片，用尽可能短的时间完成用户的请求。也就是使程序的响应速度更快 。
    * 应用场景：
        * 多任务处理。多个用户请求服务器，服务端程序可以开启多个线程分别处理每个用户的请求，互不影响。
        * 单个大任务处理。下载一个大文件，可以开启多个线程一起下载，减少整体下载时间。
        
* 线程调度
    * 指CPU资源如何分配给不同的线程。常见的两种线程调度方式：
        * 分时调度
            * 所有线程轮流使用 CPU 的使用权，平均分配每个线程占用 CPU 的时间。
        * 抢占式调度
            * 优先让优先级高的线程使用 CPU，如果线程的优先级相同，那么会随机选择一个(线程随机性)，
            
#### 二、线程的创建与启动
>java虚拟机是支持多线程的，当运行Java程序时，至少已经有一个线程了，那就是main线程。

* 创建线程的简单方式有两种：
    * 继承Thread类
        ```
            class MyThread extends Thread{
                public void run(){
                        fori{
                            sout(Thread.currentThread.getName() + ":" + i);
                        }
                    }
            }
        ```
      
    * 实现Runnable接口
    ```
            class MyRunnable implements Runnable{
                     public void run(){
                              fori{
                                  sout(Thread.currentThread.getName() + ":" + i);
                              }
                     }  
            }
    ```  
    * 两种方式启动线程
    ```java
  public class Demo{
          public static void main(String[] args){
            //继承Thread
              MyThread mt = new MyThread();
              MyThread mt2 = new MyThread();
              my.start();
              my2.start();
          
            //实现Runnable接口
              MyRunnable mr = new MyRunnable();
              Thread t1 = new Thread(mr);
              Thread t2 = new Thread(mr);
              t1.start();
              t2.start();
          }
  }
    ```
* 注意事项
    * 手动调用run方法不是启动线程的方式，只是普通方法调用。
    * start方法启动线程后，run方法会由JVM调用执行。
    * 不要重复启动同一个线程，否则抛出异常IllegalThreadStateException
    * 不要使用Junit单元测试多线程，不支持，主线程结束后会调用System.exit() 直接退出JVM;  
    
* 两种创建线程方式比较：
    * 继承Thread类
        * 使用相对简单
        * 有单继承限制
        * 数据不太方便
    * 实现Runnable接口    
        * 使用相对麻烦
        * 打破了单继承的限制
        * 数据共享更加方便
    >Thread类本身也是实现了Runnable接口的，run方法都来自Runnable接口，run方法也是真正要
     执行的线程任务

#### 三、Thread类
* 构造方法                                                                                                                                                                      
    * public Thread() :分配一个新的线程对象。
    * public Thread(String name) :分配一个指定名字的新的线程对象。
    * public Thread(Runnable target) :分配一个带有指定目标新的线程对象。
    * public Thread(Runnable target,String name) :分配一个带有指定目标新的线程对象并指定名字。
    
* 常用方法....

#### 四、 线程生命周期

* 传统线程模型的五种线程状态   
  >传统线程模型中把线程的生命周期描述为五种状态：新建（New）、就绪（Runnable）、运行  
   （Running）、阻塞（Blocked）、死亡（Dead）。CPU需要在多条线程之间切换，  
   于是线程状态会多次在运行、阻塞、就绪之间切换
       
* 1.新建
    * 当一个Thread类或其子类的对象被声明并创建时，新生的线程对象处于新建状。此时它和其他Java对象
      一样，仅仅由JVM为其分配了内存，并初始化了实例变量的值。此时的线程对象并没有任何线程的动态
      特征，程序也不会执行它的线程体run()。
* 2.就绪
    * 但是当线程对象调用了start()方法之后，线程就从新建状态转为就绪状态。这时线程并未执行，只是具
        备了运行的条件，还需要获取CPU资源后才能执行。
* 3.运行
    * 如果处于就绪状态的线程获得了CPU资源，开始执行run()方法的线程体代码，则该线程处于运行状态。
        如果计算机只有一个CPU，在任何时刻只有一个线程处于运行状态，如果计算机有多个处理器，将会有
        多个线程并行(Parallel)执行。
      当然，美好的时光总是短暂的，而且CPU讲究雨露均沾。对于抢占式策略的系统而言，系统会给每个可
      执行的线程一个小时间段来处理任务，当该时间用完，系统会剥夺该线程所占用的资源，让其回到就绪
      状态等待下一次被调度。此时其他线程将获得执行机会，而在选择下一个线程时，系统会适当考虑线程
      的优先级。
* 4.阻塞
    * 当在运行过程中的线程遇到某些特殊情况时，线程会临时放弃CPU资源，不再执行，即进入阻塞状态。
        比如：线程调用了sleep()方法，会主动放弃所占用的CPU资源。
* 5.死亡
    * 线程完成任务结束或意外终止后，线程就处于死亡状态。 
    
#### 五、线程安全
>当我们使用多个线程访问同一资源（可以是同一个变量、同一个文件、同一条记录等）的时候，但是如
 果多个线程中对资源有读和写的操作，就会出现前后数据不一致问题，这就是线程安全问题。            

* 线程安全问题的出现因为具备了以下条件
    1. 多线程执行
    2. 共享数据
    3. 多条语句操作共享数据
    
* 线程安全问题解决方式
    * 同步方法：synchronized 关键字直接修饰方法，表示同一时刻只有一个线程能进入这个方法，其他线
      程在外面等着。
      
    * 同步代码块：synchronized 关键字可以用于某个区块前面，表示只对这个区块的资源实行互斥访问。
    
* 锁对象选择
    * 锁对象可以是任意类型。
    * 多个线程对象 要使用同一把锁        
    
* 同步代码块的锁对象
    * 锁对象可以是任意类型。
    * 多个线程对象 要使用同一把锁。
    * 习惯上先考虑this，但是要注意是否同一个this                
    
* 同步方法的锁对象
    * （1）静态方法：当前类的Class对象
    * （2）非静态方法：this    
    
>锁的范围太小：不能解决安全问题，要同步所有操作共享资源的语句。  
 锁的范围太大：因为一旦某个线程抢到锁，其他线程就只能等待，所以范围太大，效率会降低，  
 不能合理利用CPU资源。

#### 六、等待唤醒机制

* 线程间通信
    * 为什么要处理线程间通信：
        >多个线程在处理同一个资源，但是处理的动作（线程的任务）却不相同。而多个线程并发执行时, 在默
         认情况下CPU是随机切换线程的，当我们需要多个线程来共同完成一件任务，并且我们希望他们有规律
         的执行, 那么多线程之间需要一些通信机制，可以协调它们的工作，以此来帮我们达到多线程共同操作一份数据。  
         比如：线程A用来生成包子的，线程B用来吃包子的，包子可以理解为同一资源，线程A与线程B处理的
         动作，一个是生产，一个是消费，此时B线程必须等到A线程完成后才能执行，那么线程A与线程B之间
         就需要线程通信，即—— 等待唤醒机制。
    
* 等待唤醒机制
    * 什么是等待唤醒机制
        >这是多个线程间的一种协作机制。谈到线程我们经常想到的是线程间的竞争（race），比如去争夺锁，
        但这并不是故事的全部，线程间也会有协作机制。
        就是在一个线程满足某个条件时，就进入等待状态（wait()/wait(time)）， 等待其他线程执行完他们  
        的指定代码过后再将其唤醒（notify()）;或可以指定wait的时间，等时间到了自动唤醒；在有多个线程
        进行等待时，如果需要，可以使用 notifyAll()来唤醒所有的等待线程。wait/notify 就是线程间的一种协
        作机制。
    
        *  1.wait：线程不再活动，不再参与调度，进入 wait set 中，因此不会浪费 CPU 资源，也不会去竞争锁了，
                这时的线程状态即是 WAITING或TIMED_WAITING。它还要等着别的线程执行一个特别的
                动作，也即是“通知（notify）”或者等待时间到，在这个对象上等待的线程从wait set 中释放出
                来，重新进入到调度队列（ready queue）中
        *  2.notify：则选取所通知对象的 wait set 中的一个线程释放；
        *  3.notifyAll：则释放所通知对象的 wait set 上的全部线程。
        
    > 被通知线程被唤醒后也不一定能立即恢复执行，因为它当初中断的地方是在同步块内，而此刻它
      已经不持有锁，所以她需要再次尝试去获取锁（很可能面临其它线程的竞争），成功后才能在当
      初调用 wait 方法之后的地方恢复执行。

* 总结如下：
    * 如果能获取锁，线程就从 WAITING 状态变成 RUNNABLE（可运行） 状态；
    * 否则，线程就从 WAITING 状态又变成 BLOCKED（等待锁） 状态     
    
* 调用wait和notify方法需要注意的细节
    * 1.wait方法与notify方法必须要由同一个锁对象调用。因为：对应的锁对象可以通过notify唤醒使用
        同一个锁对象调用的wait方法后的线程。
    * 2.wait方法与notify方法是属于Object类的方法的。因为：锁对象可以是任意对象，而任意对象的所
        属类都是继承了Object类的。
    * 3.wait方法与notify方法必须要在同步代码块或者是同步函数中使用。因为：必须要通过锁对象调用
        这2个方法。    
        
*             
        
                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                                       
