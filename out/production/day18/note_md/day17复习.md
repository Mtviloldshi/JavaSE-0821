### 集合（完结）

#### Map集合

* 存储一组键值对的一个容器

* 特点：key是唯一的，value是可以重复的，元素无序
* 常用API：
    * put(key,value);//添加元素
    * remove();//删除元素
    * get(key);//根据key获取value
    * size();//集合中元素的个数
    * ketSet();//获取所有的key并封装到一个set集合中
    * values();//获取所有的value并封装到一个Collection集合中
    * entrySet()//获取每一个键值对，把它们看成一个整体，封装刀Set集合

* HashMap实现类
    * 特点：
        * key唯一，无序，key和value都可以为null
        * 底层结构：
            * hash表=数组+链表+红黑树
        * 添加元素的原理：
            * 首次添加元素需要扩容，容量为16
            * 每次添加元素，计算key的hash值，寻找数组中的索引位置，判断此位置是否有元素 
            没有直接插入，如果有则通过比较equals判断是否重复，是则直接覆盖，否则再判断
            是树则进行树操作，如果是链表则遍历链表，判断是否重复的key，重复则覆盖value，
            否则直接尾部插入,插入了新元素判断是否需要转为红黑树或是需要扩容，当链表长度达8，
            并且数组长度大于64时，链表转为红黑树，未达到64则进行扩容操作,扩容两倍。
            > 扩容操作，因要重新计算hash，重新分布元素，所以是很消耗性能的操作  
        
            * 构造：
            * new hashMap()//未初始化容量
            * new hashMap(int initialCapacity)
            
* LinkedHashMap
    * 特点：key唯一，有序的，通过一个双向链表保证了元素的插入顺序。          
    
* TreeMap
    * 特点: key唯一，无序的，实现排序，元素必须可以比较大小,实现（Comparable，Comparator）    
    * 底层结构：红黑树
    
#### Collection工具类

#### 总结    

* 1.什么是集合？
* 2.有数组为什么还要用集合？
* 3.为什么提供这么多集合？
* 4.这些集合都有什么特点？
    * Collection: 存储一组对象，
        * List: 元素有序，可重复
            * ArrayList: 线程不安全的
                * 特点：查询快，增删慢
                * 底层结构：数组
            * LinkedList:线程不安全的
                * 特点: 查询慢、增删快
                * 底层结构：双向链表
            * Vector:
                * 特点：线程安全的，效率低
                * 底层结构：数组
                    * Stack:
        * Set:元素唯一
            * HashSet:无序的，增删、查询都快
                * 特点: 元素唯一
                * 底层结构，哈希表=数组+链表+红黑树
                * LinkedHashSet:
                    * 特点：元素有序
                    * 底层结构：哈希表=数组+链表+红黑树 ，双向链表保证了元素有序
            * TreeSet：
                * 特点：实现排序的，查询效率高于链表，增删效率高于数组
                * 底层结构：红黑树
    * Map: 存储一组映射，键值对 键唯一，值可以重复   
        * HashMap:  元素无序 线程不安全
            * 特点： key和value都可以为null，线程不安全的  
            * 底层结构 ： 哈希表 = 数组 + 链表 + 红黑树        
            * LinkedHashMap: 
                * 特点：
                    * 元素有序
                * 底层结构：hash表 + 双向链表，保证了数组的顺序
        * TreeMap: 实现了排序
                * 底层结构 ： 红黑树
        * HashTable: 线程安全
            * Properties:
    * Collections: 
    
    * jdk8添加元素操作
    > new HashMap()时，数组长度为0，加入第一个元素时，底层数组扩容为16，然后计算当前key的hashCode()，
    进行取模，确定元素在底层数组中的位置，直接添加；
    往后再添加元素时，先计算key的hashCode()值取模确定其在数组上的位置，如果这个位置没有数据直接插入，如果这个位置有数据，
    先与这个位置上的hashCode()值是否相等，如果相等，则比较其equals()是否相等，两个都相等，则这两个对象是相同对象，用新插入对象的value，
    覆盖原对象的value。如果这个两对象不相等，则循环比较这个数组上的链表对象，相等则新value覆盖原value，如果循环完，最后都不相等，
    先判断当前存储方式是链表结构还是，树结构，如果是树结构，按照树结构的插入方式进行插入，如果是链表，则先判断node数组上的链表长度是否小于8，
    如果小于8，则从链表尾部插入元素，然添加结束结束，如果等于8，并且数组长度小于64，则把数组进行扩容，并重新计算个元素的hash值排序各元素在数组中的位置，
    如果长度大于64，则将链表转换为树结构,进行树结构的添加插入操作。   
    
    * 删除操作
    >判断传入的数据是否为空，如果为空则直接返回null，如果不为空则通过hash值确定其在node数组中的位置，如果找到，先判断其是链表结构还是树结构，如果是树结构则判断
    则删除之后判断树长度是否小于6，如果小于6，树结构退化为链表结构，如果是链表，直接删除

    * jdk8 较之前版本的区别
    * 底层结构变为了 node数组 + 链表 + 红黑树
    * 由数组类型由entry变为了node类型
    * new HashMap(),先不创建数组长度，第一次添加元素时，创建长16的node类型数组
    * 链表长度达到8，并且数组长度大于64时，存储类型由链表结构转为treeNode结构
    * 插入数据到链表时，插入到链表尾部，七上八下。
* 5.为什么会有这些特特点？
* 6.常用API以及遍历操作